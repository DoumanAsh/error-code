//! Alternative `Error`
//!
//! # Requirements
//!
//! - `alloc` - Crate uses allocator to create dynamic message, when necessary.
//!
//! # Features
//!
//! - `std` - enables `std::error::Error` implementation
//! - `ufmt` - enables `ufmt` formatting implementation
//!
//! # Categories
//!
//! Library introduces the concept of categories, similar to that of C++ `std::error_category`
//! Each category can be used to describe set of integral error codes.
//!
//! Following implementations are builtin:
//!
//! - [Generic](struct.GenericCategory.html) - POSIX category.

#![no_std]
#![warn(missing_docs)]

extern crate alloc;
#[cfg(feature = "std")]
extern crate std;

use core::fmt;

mod generic;
pub use generic::GenericCategory;

///Describes category of Error, defining it's semantics.
pub trait Category: Clone + Copy {
    /// Returns name that describes the category.
    fn name(&self) -> &'static str;

    /// Returns the explanatory text for the code.
    fn message(&self, code: i32) -> alloc::borrow::Cow<'_, str>;
}

#[derive(Clone, Copy)]
///Describes error code in particular category.
pub struct ErrorCode<C> {
    code: i32,
    category: C,
}

impl ErrorCode<GenericCategory> {
    #[inline]
    ///Creates new generic error code
    ///
    ///User should rely on [libc](https://crates.io/crates/libc) to obtain definition of POSIX error.
    pub fn new_generic(code: i32) -> Self {
        Self::new(code, GenericCategory::new())
    }

    #[inline]
    ///Retrieves last error, generated by runtime
    pub fn last_generic() -> Self {
        Self::new(generic::get_last_error(), GenericCategory::new())
    }
}

impl<C: Category> ErrorCode<C> {
    #[inline]
    ///Creates new error code in provided category.
    pub fn new(code: i32, category: C) -> Self {
        Self {
            code,
            category,
        }
    }
}

impl<C: Category> fmt::Debug for ErrorCode<C> {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} error {}: {}", self.category.name(), self.code, self.category.message(self.code))
    }
}

impl<C: Category> fmt::Display for ErrorCode<C> {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        <Self as  core::fmt::Debug>::fmt(self, f)
    }
}

#[cfg(feature = "ufmt")]
impl<C: Category> ufmt::uDebug for ErrorCode<C> {
    fn fmt<W: ufmt::uWrite + ?Sized>(&self, f: &mut ufmt::Formatter<'_, W>) -> Result<(), W::Error> {
        f.write_str(self.category.name())?;
        f.write_str(" error ")?;

        {
            match self.code {
                0 => f.write_str("0: "),
                mut code => {
                    let is_neg = if code < 0 {
                        code = -code;
                        true
                    } else {
                        false
                    };

                    let mut buffer = unsafe {
                        core::mem::MaybeUninit::<[u8; 12]>::uninit().assume_init()
                    };
                    let mut buffer_idx = 0;
                    while code != 0 {
                        let rem = code % 10;
                        unsafe {
                            *buffer.get_unchecked_mut(buffer_idx) = rem as u8 + b'0';
                        }
                        buffer_idx += 1;
                        code = code / 10;
                    }

                    if is_neg {
                        unsafe {
                            *buffer.get_unchecked_mut(buffer_idx) = b'-';
                        }
                        buffer_idx += 1;
                    }

                    f.write_str(unsafe {
                        let buffer = &mut buffer[..buffer_idx];
                        buffer.reverse();
                        core::str::from_utf8_unchecked(buffer)
                    })?;

                    f.write_str(": ")
                },
            }?
        }

        f.write_str(&self.category.message(self.code))
    }
}

#[cfg(feature = "ufmt")]
impl<C: Category> ufmt::uDisplay for ErrorCode<C> {
    #[inline]
    fn fmt<W: ufmt::uWrite + ?Sized>(&self, f: &mut ufmt::Formatter<'_, W>) -> Result<(), W::Error> {
        <Self as ufmt::uDebug>::fmt(self, f)
    }
}

#[cfg(feature = "std")]
impl<C: Category> std::error::Error for ErrorCode<C> {}
